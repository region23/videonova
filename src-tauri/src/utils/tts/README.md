# TTS Audio Synchronizer Library

Эта библиотека на Rust предназначена для создания синхронизированной русской озвучки на основе переведённых VTT-субтитров и аудиодорожки, полученной с помощью OpenAI TTS API. Библиотека обеспечивает точное соответствие длительности озвучки оригинальному видео, а также включает возможности по обработке аудио для повышения качества результата.

---

## Что делает библиотека

- **Парсинг VTT-субтитров:**  
  Извлекает реплики с временными метками и текстом из файла формата WebVTT. Тайминги остаются неизменными.

- **Генерация аудиофрагментов:**  
  Асинхронно отправляет запросы к OpenAI TTS API (модель `tts-1-hd`) с параметром `speed = 1.0` для каждой реплики. Запросы выполняются пакетами для повышения производительности.

- **Декодирование аудио:**  
  Полученные WAV-данные декодируются в PCM-сэмплы (f32) с использованием библиотеки [hound](https://crates.io/crates/hound). Для опционального анализа исходного аудио (mp3/m4a) используется [symphonia](https://github.com/pdeljanov/Symphonia).

- **Корректировка длительности (Time-Stretching):**  
  С помощью библиотеки [rubato](https://crates.io/crates/rubato) аудиофрагменты ускоряются или замедляются так, чтобы их длительность точно соответствовала таймингу, указанному в VTT.  
  - Если фактическая длительность больше целевой, применяется коэффициент ускорения:  
    \[
    \text{speed\_factor} = \frac{\text{actual\_duration}}{\text{target\_duration}}
    \]
    без ограничения сверху (аудио обрабатывается без обрезки).
  - Если аудио короче, применяется замедление до минимума 0.9, а при необходимости в конец добавляется тишина.

- **Обработка границ аудиофрагментов:**  
  Применяются короткие эффекты fade‑in и fade‑out для устранения щелчков при склейке фрагментов.

- **Склейка аудиофрагментов:**  
  Все обработанные фрагменты объединяются в один итоговой PCM-поток.

- **Нормализация громкости:**  
  Библиотека позволяет опционально передать путь к исходному аудиофайлу (например, mp3 или m4a). При наличии исходного файла происходит анализ его громкости (RMS‑уровень), и итоговой аудиофайл нормализуется так, чтобы его громкость соответствовала оригиналу.

- **Кодирование итогового аудио:**  
  Объединённое аудио кодируется в формат WAV с помощью библиотеки [hound](https://crates.io/crates/hound).

- **Отслеживание прогресса:**  
  Асинхронно отправляются обновления о текущем этапе выполнения процесса через канал (например, используя `tokio::sync::mpsc`). Это позволяет информировать пользователя о ходе работы (парсинг, генерация TTS, обработка фрагментов, склейка, нормализация, кодирование).

---

## Структура проекта

- **Модуль `vtt`:**  
  Парсинг VTT-субтитров и преобразование временных меток в секунды.

- **Модуль `tts`:**  
  Асинхронное обращение к OpenAI TTS API для генерации аудио по тексту.

- **Модуль `audio`:**  
  - Декодирование WAV (hound) и исходного аудио (symphonia) в PCM-сэмплы.
  - Корректировка длительности аудио с использованием rubato.
  - Применение эффектов fade‑in/fade‑out.
  - Вычисление RMS‑уровня для нормализации громкости.
  - Кодирование финального PCM в WAV.

- **Модуль `synchronizer`:**  
  Объединяет все этапы: парсинг, TTS, аудиообработка, склейка фрагментов, нормализация громкости и запись файла. Также передаёт обновления прогресса через асинхронный канал.

- **Тип `ProgressUpdate`:**  
  Определяет этапы выполнения процесса (например, `ParsingVTT`, `TTSGeneration`, `ProcessingFragment`, `MergingFragments`, `Normalizing`, `Encoding`, `Finished`).

---

## Как использовать

### Установка

Добавьте зависимости в свой `Cargo.toml`:

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.11", features = ["json", "rustls-tls"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rubato = "0.11"
hound = "3.4"
symphonia = "0.5"
anyhow = "1.0"
futures = "0.3"
```

### Пример использования

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    use std::path::Path;
    use tokio::sync::mpsc;
    use your_library::synchronizer::{process_sync, ProgressUpdate, SyncConfig};

    // Создаем канал для получения обновлений прогресса.
    let (tx, mut rx) = mpsc::channel::<ProgressUpdate>(10);

    // Запускаем задачу, которая выводит обновления о прогрессе.
    tokio::spawn(async move {
        while let Some(update) = rx.recv().await {
            println!("Прогресс: {:?}", update);
        }
    });

    let config = SyncConfig {
        api_key: "YOUR_OPENAI_API_KEY",
        vtt_path: Path::new("subtitles_ru.vtt"),
        output_wav: Path::new("final_audio.wav"),
        // Опционально: путь к исходному аудио для нормализации громкости (mp3/m4a)
        original_audio_path: Some(Path::new("original_audio.mp3")),
        progress_sender: Some(tx),
    };

    process_sync(config).await?;
    Ok(())
}
```

---

## Требования

- **Rust** (стабильная версия)
- Асинхронный runtime: [Tokio](https://tokio.rs/)
- Библиотеки для работы с HTTP: [reqwest](https://crates.io/crates/reqwest)
- Библиотеки для работы с аудио: [hound](https://crates.io/crates/hound), [symphonia](https://github.com/pdeljanov/Symphonia)
- Библиотека для time-stretching: [rubato](https://crates.io/crates/rubato)
- Другие зависимости: [serde](https://crates.io/crates/serde), [serde_json](https://crates.io/crates/serde_json), [anyhow](https://crates.io/crates/anyhow), [futures](https://crates.io/crates/futures)

---

## Лицензия

Укажите вашу лицензию здесь (например, MIT, Apache 2.0 и т.д.).

---

## Заключение

Эта библиотека позволяет создавать синхронизированную озвучку на основе переведённых VTT-субтитров, генерируя аудиофрагменты через OpenAI TTS API, корректируя длительности с помощью rubato и объединяя их с плавными переходами. Опциональная нормализация громкости с анализом исходного аудио позволяет добиться соответствия звучания оригиналу. Асинхронные обновления прогресса помогут отслеживать этапы выполнения процесса.

При возникновении вопросов или предложений по улучшению, пожалуйста, создайте issue или pull request в репозитории проекта.